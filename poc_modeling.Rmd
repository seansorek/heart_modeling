---
title: "Heart Modeling"
author: "Sean Sorek"
date: '`r Sys.Date()`'
output: pdf_document
geometry: margin = 0.5in
fontsize: 12pt
editor_options: 
  chunk_output_type: console
urlcolor: blue
---



```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE,
                      comment = NA,
                      warning = F,
                      message = F,
                      fig.align = "center",
                      fig.width = 8,
                      fig.height = 4)
set.seed(1)

def.chunk.hook  <- knitr::knit_hooks$get("chunk")
knitr::knit_hooks$set(chunk = function(x, options) {
  x <- def.chunk.hook(x, options)
  ifelse(options$size != "normalsize", paste0("\n \\", options$size,"\n\n", x, "\n\n \\normalsize"), x)
})

```

# Setup

```{r}
nx <- 50 # length of x direction
ny <- 50 # length of y direction
dx <- 0.1 # Spatial step size
dy <- 0.1
dt <- 0.001 # Time step
t_total <- 10 # Total time
nt <- t_total / dt  # Number of time steps

# unused for simplicity for now
chi <- 1.0  # cell surface to volume ratio
D <- 0.1 # conductivity tensor, assumed 1D for easy multiplication
c_m <- 1 # transmembrane capacitance
```

$D$, the conductivity tensor, is a combined constant that represents some combination of $\chi$ and $C_m$. i.e. you dont need to have them all in the same model as long as the numbers are calibrated correctly. It can be modelled as either a scalar for simple models or a tensor to model propogation along fibers. Once I have a fiber field set up, I can use the tensor in the notes.

# 2D  Monodomain Electrophysical Model

```{r}
u <- array(0, dim = c(nx,ny))
u[floor(nx/2),floor(ny/4)] = 10

#laplacian pre-allocation
l <- array(0, dim = c(nx,ny))

I_ion <- function(u, w = NA) {
  u^3 - u
}

x_pos <- (0:(nx*ny-1) %% nx + 1) / nx
y_pos <- (0:(nx*ny-1) %/% nx + 1)  / ny
for (t in 1:nt) {
  #only calculate the interals since we assume the boundary is constant
  for (i in 2:(nx-1)) {
    for (j in 2:(ny-1)) {
      # finite difference approximation for laplacian
      l[i,j] <- (u[i+1,j] + u[i-1,j] + u[i,j+1] + u[i,j-1] - 4*u[i,j]) / (dx * dy)
    }
  }
  
  # forward euler using the monodomain equation
  u <- u + dt*(D * l - I_ion(u = u))

  if (t %% 1000 == 0) {
      pal <- character(nx*ny)
  for (i in 1:nx){
    for (j in 1:ny) {
      pal[i + (j-1) * nx] = rgb(u[i,j] / max(u),
                                (u[i,j] / max(u))^2,
                                0,
                                alpha = u[i,j] / max(u))
    }
  }

    plot(x_pos,y_pos, col = pal, main = paste("t =",t), pch = 19)
  }
}


```

